#+title: cluj
#+author: Keith Irwin
#+startup: showall

Clojure bundled with a lot of handy "shell scripting" libs. Put the
uberjar on your classpath and you can have lots of handy functionality
for shell-scripting, or whatever.

* status

[[https://github.com/zentrope/cluj/releases/tag/v0.5.0][Version 6]].

You can get the release on the [[https://github.com/zentrope/cluj/releases][releases]] page.

- Download the jar

- Download the script

- Put both the jar and the script on your =$PATH= and =chmod u+x
  cluj= the script. It expects the jar in the same directory as the
  script itself, or in =~/.cluj=.

Someday, the =cluj= script should self-install, and the jar itself
should contain some code to update itself, but that day isn't today.

* bundled libs

All of these are mashed together into an uberjar, the "main" of which
is the Clojure REPL.


#+begin_src clojure
[[org.clojure/clojure            "1.9.0-alpha14"]
 [org.clojure/core.async         "0.2.395"]
 [org.clojure/data.json          "0.2.6"]
 [org.clojure/tools.cli          "0.3.5"]
 [org.clojure/tools.nrepl        "0.2.12"]
 [org.clojure/tools.logging      "0.3.1"]
 [org.clojure/core.logic         "0.8.11"]
 [ch.qos.logback/logback-classic "1.1.8"]
 [clj-time                       "0.13.0"]
 [com.cemerick/pomegranate       "0.3.1" :exclusions [org.codehaus.plexus/plexus-utils]]
 [http-kit                       "2.3.0-alpha1"]
 [me.raynes/fs                   "1.4.6"]
 [pandect                        "0.6.1"]
 [cider/cider-nrepl              "0.14.0"]
 [com.stuartsierra/component     "0.3.2"]
 [com.hierynomus/sshj            "0.19.1"]
 [net.sf.expectit/expectit-core  "0.8.2"]
 [javax.mail/mail                "1.5.0-b01"]
 [hiccup                         "1.0.5"]
 [com.datomic/datomic-free       "0.9.5544" :exclusions [org.slf4j/jcl-over-slf4j
                                                         org.slf4j/log4j-over-slf4j
                                                         org.slf4j/jul-to-slf4j
                                                         org.slf4j/slf4j-log4j12
                                                         org.slf4j/slf4j-api]]]
#+end_src

* maybe add?

 - jdbc api?
 - postgres, mysql, [[http://h2database.com/html/cheatSheet.html][h2]] and [[https://github.com/xerial/sqlite-jdbc][sql-lite]] drivers?

* example script

Imagine you want to use a shell script to build your Clojure app
rather than a full blown system. The hardest part of that system is
resolving dependencies. =Cluj= includes =pomegranate=, so you can role
your own resolver:

#+begin_src clojure
  #!/usr/bin/env cluj

  (require '[clojure.string :as s])
  (require '[cemerick.pomegranate.aether :as a])

  (def deps
    '[[org.clojure/clojure "1.8.0"]
      [me.raynes/fs "1.4.6"]
      [http-kit "2.1.19"]])

  (def repos
    {"central" {:url "http://repo1.maven.org/maven2/"}
     "sonatype" {:url "http://oss.sonatype.org/content/repositories/releases"}
     "java.net" {:url "http://download.java.net/maven/2"}
     "clojars" {:url "http://clojars.org/repo"}})

  (defn jar-list
    [deps repos]
    (-> (a/resolve-dependencies :coordinates deps :repositories repos)
        (a/dependency-files)))

  (defn class-path
    [deps repos]
    (->> (jar-list deps repos)
         (map #(.getAbsolutePath %))
         (s/join (System/getProperty "path.separator"))))

  ;; Print path to each jar
  (doseq [jar (sort (jar-list deps repos))]
    (println "jar =>" (.getAbsolutePath jar)))

  ;; Dump the classpath
  (println "classpath:")
  (println (class-path deps repos))
#+end_src

If the =cluj= script is on your =$PATH=, for instance, in =~/bin=, you
can run this script as:

#+begin_src sh
  cluj deps.clj
#+end_src

Given that the first line is =!/usr/bin/env cluj= you can set the
execute permission on the script and run it directly:

#+begin_src sh
  chmod u+x deps.clj
  ./deps.clj
#+end_src

again, as long as =cluj= is on your =$PATH=. With a few changes
(removing the "jar =>" print stuff), you could do something like:

#+begin_src sh
  export CLASSPATH=`deps.clj`
#+end_src
